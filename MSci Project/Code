
import numpy as np
import matplotlib.pyplot as plt

dtheta = 15./(60.**2)   #these will be given by 21cm later on
theta = 4. #gives 960 points
size = int(theta/dtheta)

# specify circle parameters: centre ij and radius
z = np.zeros((size,size))
ci,cj=int(size/2),(size/2) #centre point
cr=100  #arbitary for now

# Create index arrays to z
I,J=np.meshgrid(np.arange(z.shape[0]),np.arange(z.shape[1]))

# np.sqrt((I-ci)**2+(J-cj)**2) calculates distance of all points to centre
# Assign value of 1 to those points where distance to centre is less that cr:
z[np.where(np.sqrt((I-ci)**2+(J-cj)**2)<cr)]=100


#Fast Fourier Transform of z
zhat=np.fft.fft2(z)
zhat=np.fft.fftshift(zhat)
y = np.fft.ifft2(zhat)    #y is check of re-inversed
y = np.real(y)
zhatabs=abs(zhat)
#zhat = np.log(zhat)
#print zhat

'''
im = plt.imshow(zhat, cmap='hot')
plt.colorbar(im, orientation='horizontal')
plt.show()

new = plt.imshow(y, cmap='hot')
plt.colorbar(new, orientation='horizontal')
plt.show()
'''

#random positions in km - ARBITARY LAMBDA = 0.18m - more centrally clustered seem better
xpos = (np.random.rand(1,50)-0.5)*(1000) #the lower this the more clustered
ypos = (np.random.rand(1,50)-0.5)*(1000) #this is to order of our largest baseline
#xpos = [10, 10, -10, -10, 10, 0, -10, 0, 0, 20, 20, -20, -20, 20, 0, -20, 0, 5, 5, -5, -5, 5, 0, -5, 0, 10, 35, -25, -35, 7, 12, -24, 8]
#ypos = [10, -10, 10, -10, 0, 10, 0, -10, 0, 20, -20, 20, -20, 0, 20, 0, -20, 5, -5, 5, -5, 0, 5, 0, -5, 35, -10, 35, -25, 0, -23, 13, -32]
#dx = []
#dy = []

#for these positions we need to times by inverse of scale factor from image FT conversion, i.e. theta min = lamda/bmax,
scaling = 0.5*size*dtheta  #this is scaling due to half width being given by 1/dtheta

for i in range (20):
    lda = (1+i)*(1.5)   #this gives ranges of lamda from 1.5 to 15


    dx = []
    dy = []
    #this takes the positions and turns them into baselines (no rotation included yet), shifted so they correspond with centre of image
    for i in range(np.size(xpos)):
        for j in range(np.size(ypos)):
            if i != j:
                dx.append(ci + int(scaling*((xpos[0,i]-xpos[0,j])/lda)))  #doesn't take into account rotation of earth or angle of object
                dy.append(cj + int(scaling*((ypos[0,i]-ypos[0,j])/lda)))

    #print dx
    #print dy

    #create the measured array
    image = np.zeros((2*ci,2*cj),'complex')

    countvar = 0
    #this uses baseline positions to sample - dx/dy[i] gives baseline positions, which then sample the fourier space zhat
    for i in range(len(dx)):
        if dx[i] < size and dy[i] < size and dx[i] > 0 and dy[i] > 0:   #this is to stop crashing
            image[dx[i], dy[i]] = zhat[dx[i], dy[i]]
        else:
            print ("error, image out of zhat bounds, baseline is", dx[i] , dy[i])
            countvar += 1

    print ("percentage of baselines ignored", countvar/(100.*len(dx)))

    #shows sample fourier image
    image2 = abs(image)
    image2 = plt.imshow(image2, cmap='hot')


    plt.colorbar(image2, orientation='horizontal')
    plt.show()

    #shows inverse image
    imageinv = np.fft.ifft2(image)
    imageinv2 = abs(imageinv)
    imageinv2 = plt.imshow(imageinv2, cmap='hot')
    plt.colorbar(imageinv2, orientation='horizontal')
    plt.show()